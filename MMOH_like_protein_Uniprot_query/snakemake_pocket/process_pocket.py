"""
2023/07/04
rewriting: Script to find "pocket" within some given residues

#pocket script takes in input a set of pdb files
generated by fpocket. Pockets in these PDBs are residue objects

"""
#pocket script

from Bio.PDB import PDBParser
import os, sys
import numpy as np
import pandas as pd

## Try: search the pocket folder pdbs instead

#main output directory
FPOCKET_OUTPUT = sys.argv[1]

#file for identifying which residues to use when search for fpocket
#generated from foldseek superimpose search
MAPPING_FILE = sys.argv[2]

#distance in angstroms to search for pocket
DISTANCE = float(sys.argv[3])

#output directory
OUTPUT_DIR = sys.argv[4]

#directory for original pdb files, not processed by fpocket
#fpocket written files sometimes have strange formatting
PDB_DIRECTORY = sys.argv[5]

def patchfix_pdb(dataframe):
    """
    BAD FUNCTION, 
    temporary fix for bad pdb column formating

    take column and retun list of pdb codes
    """
    assert 'pdb_name' in dataframe.columns, 'pdb_name column not found'
    return [code[1].split('_')[1] for code in dataframe['pdb_name'].str.split('.')]

def get_pdb_obj(code, pdb_dir=PDB_DIRECTORY):
    """
    return a bio.pdb object by searching a code in a directory
    code is the capitalized 4 letter code
    """
    parser = PDBParser()
    pdb_file = [file for file in os.listdir(pdb_dir) if code in file][0]
    pdb_file = [file for file in pdb_file if file.endswith('.pdb')][0]
    return parser.get_structure('x', os.path.join(pdb_dir, pdb_file))

def get_residue_mapping(mapping_file):
    """
    return a dataframe which maps
    residues to use and their corresponding pdb code
    
    mapping file's number of column varies depending on 
    how many coordinates were used in previous step
    """
    file = pd.read_csv(mapping_file, sep='\t')
    
    #select numeric columns to use
    numeric_cols = file[[col for col in file.columns if 'num' in col]]
    
    #fix pdb column
    pdb_code = patchfix_pdb(file)
    mapping = dict(zip(pdb_code, numeric_cols.values.tolist()))
    return mapping

def get_distance(coord1, coord2):
    """Get Euclidean distance between two coordinates"""
    return np.linalg.norm(coord1 - coord2)

def residue_to_coordinate(pdb_code, residue_number):
    """
    Return calpha coordinate of given pdb code
    Assuming pdb object single chain
    """
    #fetch file from code
    pdb_obj = get_pdb_obj(pdb_code)
    for residue in pdb_obj.get_residues():
        if residue.get_id()[1] == residue_number:
            return (residue['CA'].coord)
    print(f'Error, no residue found for pdb object {pdb_obj}')
    return 'NA'

#Parse the raw way
def raw_parser(pdb_file, coordinate, distance):
    """
    Search the pdb file for atoms within
    some distance of given coordinate

    param: pdb_file: pdb file path that gives residues in contact with pocket 
    param: coordinate: tuple of coordinates
    param: distance: distance in angstroms

    return pocket number if the file contains a pocket close to specified coordinate
    """
    with open(pdb_file, 'r') as pdb:
        for line in pdb:
            if line.startswith('ATOM'):
                #get the coordinates
                atom = line[12:16].strip()
                x = float(line[30:38].strip())
                y = float(line[38:46].strip())
                z = float(line[46:54].strip())
                #print(atom, x, y, z)
                #check distance
                if get_distance(coordinate, np.array([x, y, z])) <= distance:
                    #print('hit')
                    print(line)
                    return os.path.basename(pdb_file).split('_')[0].strip('pocket')
    
def get_pocket_attribute(pocket_number, pocket_file):
    """
    Get precomputed attributes of specified pocket from pocket file
    pocket_number: int
    pocket_file: path to pocket file
    """
    #print n number of lines from the limit
    data_string = ''
    with open(pocket_file, 'r') as f:
        for line in f:
            if f'Pocket {pocket_number} :' in line:
                #get the next 19 lines
                for i in range(19):
                    data_string += f.readline()
            else: 
                continue
    return data_string

def string_to_df(text):
    """
    Convert string of pocket attribute to table
    """
    lines = text.strip().split('\n')
    data = {}
    for line in lines:
        key, value = line.split(':')
        data[key.strip()] = value.strip()
    return pd.DataFrame(data, index=[0])

def get_all_pocket_data(pocket_number, pocket_file, coordinate, res, pdb_code):
    """
    Record information in dataframe format
    """
    table = string_to_df(get_pocket_attribute(pocket_number, pocket_file))
    table['pocket_number'] = pocket_number
    table['searched_coordinate'] = coordinate
    table['searched_residue'] = res
    table['pdb_code'] = pdb_code
    return table

def usage():
    print('Usage: python3 process_pockets.py <FPOCKET_OUT_DIR> <RESIDUE_MAPPING> <DISTANCE IN ANG> <OUTPUT_DIR>')
    print('python3 process_pockets.py fpocket_output  process_pockets_output')

######## command line arguments #########
#directory of fpocket output


def main():
    big_table = pd.DataFrame()

    #inside fpocket output
    #there is one directory per queried protein
    pocket_subdir = os.listdir(FPOCKET_OUTPUT)
    
    #pdb_to_search_res 
    pdb_to_res = get_residue_mapping(MAPPING_FILE)

    #search the pocket pdbs for each protein
    for subdir in pocket_subdir:
        pdb_code = subdir.split('_')[0]
        pocket_pdb_dir = os.path.join(FPOCKET_OUTPUT, subdir, 'pockets')
        pocket_pdbs = os.listdir(pocket_pdb_dir)
        pocket_pdbs = [file for file in pocket_pdbs if file.endswith('.pdb')]
        
        for pdb in pocket_pdbs:
            pocket_file = os.path.join(pocket_pdb_dir, pdb)
            
            #search through all specified coordinates
            residues_to_search = pdb_to_res[pdb_code]
            for res in residues_to_search:
                coordinate = residue_to_coordinate(pdb_code, res)

                #search if any detected pocket falls within specified distance
                pocket_number = raw_parser(pocket_file, coordinate, DISTANCE)
                
                #if pocket found, get the pocket attributes
                if pocket_number:
                    pocket_info_file = os.path.join(FPOCKET_OUTPUT, subdir, f'{pdb_code}_info.txt')
                    table = get_all_pocket_data(pocket_number, pocket_info_file, coordinate, res, pdb_code)
                    big_table = pd.concat([big_table, table])

                else:
                    print(f'No pocket found for {pdb_code}')
                    continue

    os.system(f'mkdir -p {OUTPUT_DIR}')
    big_table.to_csv(f'{OUTPUT_DIR}/combined_pocket_info.tsv', index=False, sep='\t')

if __name__ == '__main__':
    main()







